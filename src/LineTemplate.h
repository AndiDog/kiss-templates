// generated by kiste2cpp
#pragma once
#include <kiste/terminal.h>

#line 1 "../src/LineTemplate.kiste"
#include "command_type.h"
#include "line_type.h"

namespace kiste
{
template<typename DERIVED_T, typename DATA_T, typename SERIALIZER_T>
struct LineTemplate_t
{
  DERIVED_T& child;
  using _data_t = DATA_T;
  const _data_t& data;
  using _serializer_t = SERIALIZER_T;
  _serializer_t& _serialize;

  LineTemplate_t(DERIVED_T& derived, const DATA_T& data_, SERIALIZER_T& serialize):
    child(derived),
    data(data_),
    _serialize(serialize)
  {}
  // ----------------------------------------------------------------------
#line 7

    void open_exception_handling()
    {
      if (data.report_exceptions)
      {
        _serialize.text("try"
               "{");
      }
    }

    void close_exception_handling(const std::string& expression)
    {
      if (data.report_exceptions)
      {
        _serialize.text("}"
               "catch(...)"
               "{"
               "  _serialize.report_exception(__LINE__, \""); _serialize.escape(expression); _serialize.text("\", std::current_exception());"
               "}");
      }
    }

    void escape(const std::string& expression)
    {
      _serialize.text(""); static_assert(std::is_same<decltype(open_exception_handling()), void>::value, "$call{} requires void expression"); (open_exception_handling()); _serialize.text(""
             " _serialize.escape("); _serialize.raw(expression); _serialize.text("); "
             ""); static_assert(std::is_same<decltype(close_exception_handling(expression)), void>::value, "$call{} requires void expression"); (close_exception_handling(expression)); _serialize.text("");
    }

    void raw(const std::string& expression)
    {
      _serialize.text(""); static_assert(std::is_same<decltype(open_exception_handling()), void>::value, "$call{} requires void expression"); (open_exception_handling()); _serialize.text(""
             " _serialize.raw("); _serialize.raw(expression); _serialize.text("); "
             ""); static_assert(std::is_same<decltype(close_exception_handling(expression)), void>::value, "$call{} requires void expression"); (close_exception_handling(expression)); _serialize.text("");
    }

    void call(const std::string& expression)
    {
      _serialize.text("      "); static_assert(std::is_same<decltype(open_exception_handling()), void>::value, "$call{} requires void expression"); (open_exception_handling()); _serialize.text("\n"
             "static_assert(std::is_same<decltype("); _serialize.raw(expression); _serialize.text("), void>::value, \"$call{} requires void expression\"); ("); _serialize.raw(expression); _serialize.text("); "
             "      "); static_assert(std::is_same<decltype(close_exception_handling(expression)), void>::value, "$call{} requires void expression"); (close_exception_handling(expression)); _serialize.text("\n");
    }

    void open_string(bool& string_opened)
    {
      if (not string_opened)
      {
        _serialize.text("_serialize.text(");
      }
      string_opened = true;
    }

    void close_string(bool& string_opened)
    {
      if (string_opened)
      {
        _serialize.text(");");
      }
      string_opened = false;
    }

    void text_segment(const std::string& line)
    {
      _serialize.text("\""); _serialize.escape(line); _serialize.text("\"");
    }

    void render_none()
    {
      _serialize.text("\n");
    }

    template<typename Line>
    void render_text(const Line& line)
    {
      auto string_opened = (line.previous_type == line_type::text);
      for (const auto& segment : line.commands)
      {
        switch(segment.type)
        {
        case command_type::text:
          _serialize.text(""); static_assert(std::is_same<decltype(open_string(string_opened)), void>::value, "$call{} requires void expression"); (open_string(string_opened)); _serialize.text(""
                 ""); static_assert(std::is_same<decltype(text_segment(segment.text)), void>::value, "$call{} requires void expression"); (text_segment(segment.text)); _serialize.text("");
          break;
        case command_type::trim_trailing_return:
          _serialize.text(""); static_assert(std::is_same<decltype(close_string(string_opened)), void>::value, "$call{} requires void expression"); (close_string(string_opened)); _serialize.text("");
          break;
        case command_type::escape:
          _serialize.text(""); static_assert(std::is_same<decltype(close_string(string_opened)), void>::value, "$call{} requires void expression"); (close_string(string_opened)); _serialize.text(""
                 ""); static_assert(std::is_same<decltype(escape(segment.text)), void>::value, "$call{} requires void expression"); (escape(segment.text)); _serialize.text("");
          break;
        case command_type::call:
          _serialize.text(""); static_assert(std::is_same<decltype(close_string(string_opened)), void>::value, "$call{} requires void expression"); (close_string(string_opened)); _serialize.text(""
                 ""); static_assert(std::is_same<decltype(call(segment.text)), void>::value, "$call{} requires void expression"); (call(segment.text)); _serialize.text("");
          break;
        case command_type::raw:
          _serialize.text(""); static_assert(std::is_same<decltype(close_string(string_opened)), void>::value, "$call{} requires void expression"); (close_string(string_opened)); _serialize.text(""
                 ""); static_assert(std::is_same<decltype(raw(segment.text)), void>::value, "$call{} requires void expression"); (raw(segment.text)); _serialize.text("");
          break;
        }
      }
      if (line.next_type != line_type::text)
      {
        _serialize.text(""); static_assert(std::is_same<decltype(close_string(string_opened)), void>::value, "$call{} requires void expression"); (close_string(string_opened)); _serialize.text("");
      }
      if (line.trailing_return)
      {
        _serialize.text("\n");
      }
    }

    template<typename Line>
    void render_cpp(const Line& line)
    {
      _serialize.text(""); _serialize.raw(line.commands[0].text); _serialize.text("\n");
    }

 void old_code()
 {
      /*
      _serialize.text("    //ctx.open_text();\n"
             "    //ctx.os << \"  \";\n"
             "    //for (std::size_t i = 0; i < ctx.curly_level; ++i)\n"
             "    //{\n"
             "      //ctx.os << \"  \";\n"
             "    //}\n");
    */
      _serialize.text("\n");
 }
  // ----------------------------------------------------------------------
#line 135
};

#line 135
template<typename DATA_T, typename SERIALIZER_T>
auto LineTemplate(const DATA_T& data, SERIALIZER_T& serialize)
  -> LineTemplate_t<kiste::terminal_t, DATA_T, SERIALIZER_T>
{
  return {kiste::terminal, data, serialize};
}

#line 136
}


