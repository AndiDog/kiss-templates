// generated by kiste2cpp
#pragma once
#include <kiste/terminal.h>

#line 1 "../src/LineTemplate.kiste"
#include "segment_type.h"
#include "line_type.h"

namespace kiste
{
template<typename DERIVED_T, typename DATA_T, typename SERIALIZER_T>
struct LineTemplate_t
{
  DERIVED_T& child;
  using _data_t = DATA_T;
  const _data_t& data;
  using _serializer_t = SERIALIZER_T;
  _serializer_t& _serialize;

  LineTemplate_t(DERIVED_T& derived, const DATA_T& data_, SERIALIZER_T& serialize):
    child(derived),
    data(data_),
    _serialize(serialize)
  {}
  // ----------------------------------------------------------------------
#line 7

    void open_exception_handling()
    {
      if (data._report_exceptions)
      {
        _serialize.text(" try"
               " { ");
      }
    }

    void close_exception_handling(const std::string& expression)
    {
      if (data._report_exceptions)
      {
        _serialize.text(" }"
               " catch(...)"
               " {"
               " _serialize.report_exception(__LINE__, \""); _serialize.escape(expression); _serialize.text("\", std::current_exception());"
               " } ");
      }
    }

    void escape(const std::string& expression)
    {
      _serialize.text(""); static_assert(std::is_same<decltype(open_exception_handling()), void>::value, "$call{} requires void expression"); (open_exception_handling()); _serialize.text(""
             "_serialize.escape("); _serialize.raw(expression); _serialize.text(");"
             ""); static_assert(std::is_same<decltype(close_exception_handling(expression)), void>::value, "$call{} requires void expression"); (close_exception_handling(expression)); _serialize.text("");
    }

    void raw(const std::string& expression)
    {
      _serialize.text(""); static_assert(std::is_same<decltype(open_exception_handling()), void>::value, "$call{} requires void expression"); (open_exception_handling()); _serialize.text(""
             "_serialize.raw("); _serialize.raw(expression); _serialize.text(");"
             ""); static_assert(std::is_same<decltype(close_exception_handling(expression)), void>::value, "$call{} requires void expression"); (close_exception_handling(expression)); _serialize.text("");
    }

    void call(const std::string& expression)
    {
      _serialize.text(""); static_assert(std::is_same<decltype(open_exception_handling()), void>::value, "$call{} requires void expression"); (open_exception_handling()); _serialize.text(""
             "static_assert(std::is_same<decltype("); _serialize.raw(expression); _serialize.text("), void>::value, \"$call{} requires void expression\"); ("); _serialize.raw(expression); _serialize.text(");"
             ""); static_assert(std::is_same<decltype(close_exception_handling(expression)), void>::value, "$call{} requires void expression"); (close_exception_handling(expression)); _serialize.text("");
    }

    void open_string(bool& string_opened)
    {
      if (not string_opened)
      {
        _serialize.text("_serialize.text(");
      }
      string_opened = true;
    }

    void close_string(bool& string_opened)
    {
      if (string_opened)
      {
        _serialize.text(");");
      }
      string_opened = false;
    }

    void text_segment(const std::string& line)
    {
      _serialize.text("\""); _serialize.escape(line); _serialize.text("\"");
    }

    void render_none()
    {
      _serialize.text("\n");
    }

    template<typename Line>
    void render_text(const Line& line)
    {
      for (std::size_t i = 0; i < line._curly_level; ++i)
      {
        _serialize.text("  ");
      }
      auto string_opened = line._previous_line_ends_with_text;
      if (string_opened)
      {
        _serialize.text("                ");
      }
      for (const auto& segment : line._segments)
      {
        switch(segment._type)
        {
        case segment_type::text:
          _serialize.text(""); static_assert(std::is_same<decltype(open_string(string_opened)), void>::value, "$call{} requires void expression"); (open_string(string_opened)); _serialize.text(""
                 ""); static_assert(std::is_same<decltype(text_segment(segment._text)), void>::value, "$call{} requires void expression"); (text_segment(segment._text)); _serialize.text("");
          break;
        case segment_type::trim_trailing_return:
          break;
        case segment_type::escape:
          _serialize.text(""); static_assert(std::is_same<decltype(close_string(string_opened)), void>::value, "$call{} requires void expression"); (close_string(string_opened)); _serialize.text(""
                 ""); static_assert(std::is_same<decltype(escape(segment._text)), void>::value, "$call{} requires void expression"); (escape(segment._text)); _serialize.text("");
          break;
        case segment_type::call:
          _serialize.text(""); static_assert(std::is_same<decltype(close_string(string_opened)), void>::value, "$call{} requires void expression"); (close_string(string_opened)); _serialize.text(""
                 ""); static_assert(std::is_same<decltype(call(segment._text)), void>::value, "$call{} requires void expression"); (call(segment._text)); _serialize.text("");
          break;
        case segment_type::raw:
          _serialize.text(""); static_assert(std::is_same<decltype(close_string(string_opened)), void>::value, "$call{} requires void expression"); (close_string(string_opened)); _serialize.text(""
                 ""); static_assert(std::is_same<decltype(raw(segment._text)), void>::value, "$call{} requires void expression"); (raw(segment._text)); _serialize.text("");
          break;
        }
      }
      if (not line._next_line_starts_with_text)
      {
        _serialize.text(""); static_assert(std::is_same<decltype(close_string(string_opened)), void>::value, "$call{} requires void expression"); (close_string(string_opened)); _serialize.text("");
      }
      _serialize.text("\n");
    }

    template<typename Line>
    void render_cpp(const Line& line)
    {
      _serialize.text(""); _serialize.raw(line._segments[0]._text); _serialize.text("\n");
    }

  // ----------------------------------------------------------------------
#line 127
};

#line 127
template<typename DATA_T, typename SERIALIZER_T>
auto LineTemplate(const DATA_T& data, SERIALIZER_T& serialize)
  -> LineTemplate_t<kiste::terminal_t, DATA_T, SERIALIZER_T>
{
  return {kiste::terminal, data, serialize};
}

#line 128
}


