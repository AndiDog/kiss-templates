// generated by kiste2cpp
#pragma once
#include <kiste/terminal.h>

#line 1 "../src/LineTemplate.kiste"
namespace kiste
{
template<typename DERIVED_T, typename DATA_T, typename SERIALIZER_T>
struct LineTemplate_t
{
  DERIVED_T& child;
  using _data_t = DATA_T;
  const _data_t& data;
  using _serializer_t = SERIALIZER_T;
  _serializer_t& _serialize;

  LineTemplate_t(DERIVED_T& derived, const DATA_T& data_, SERIALIZER_T& serialize):
    child(derived),
    data(data_),
    _serialize(serialize)
  {}
  // ----------------------------------------------------------------------
#line 4

    void open_exception_handling()
    {
      if (data.report_exceptions)
      {
        _serialize.text("try"
               "{");
      }
    }

    void close_exception_handling(const std::string& expression)
    {
      if (data.report_exceptions)
      {
        _serialize.text("}"
               "catch(...)"
               "{"
               "  _serialize.report_exception(__LINE__, \""); _serialize.escape(expression); _serialize.text("\", std::current_exception());"
               "}");
      }
    }

    void escape(const std::string& expression)
    {
      _serialize.text("      "); static_assert(std::is_same<decltype(open_exception_handling()), void>::value, "$call{} requires void expression"); (open_exception_handling()); _serialize.text("\n"
             " _serialize.escape("); _serialize.raw(expression); _serialize.text("); "
             "      "); static_assert(std::is_same<decltype(close_exception_handling(expression)), void>::value, "$call{} requires void expression"); (close_exception_handling(expression)); _serialize.text("\n");
    }

    void raw(const std::string& expression)
    {
      _serialize.text("      "); static_assert(std::is_same<decltype(open_exception_handling()), void>::value, "$call{} requires void expression"); (open_exception_handling()); _serialize.text("\n"
             " _serialize.raw("); _serialize.raw(expression); _serialize.text("); "
             "      "); static_assert(std::is_same<decltype(close_exception_handling(expression)), void>::value, "$call{} requires void expression"); (close_exception_handling(expression)); _serialize.text("\n");
    }

    void call(const std::string& expression)
    {
      _serialize.text("      "); static_assert(std::is_same<decltype(open_exception_handling()), void>::value, "$call{} requires void expression"); (open_exception_handling()); _serialize.text("\n"
             " _serialize.call("); _serialize.raw(expression); _serialize.text("); "
             "      "); static_assert(std::is_same<decltype(close_exception_handling(expression)), void>::value, "$call{} requires void expression"); (close_exception_handling(expression)); _serialize.text("\n");
    }

    void cpp_line(const std::string& line)
    {
      _serialize.text(""); _serialize.raw(line); _serialize.text("");
    }

    void open_string(bool& string_opened)
    {
      if (not string_opened)
      {
        _serialize.text("_serialize.text(");
      }
      string_opened = true;
    }

    void close_string(bool& string_opened)
    {
      if (string_opened)
      {
        _serialize.text(");");
      }
      string_opened = false;
    }

    void text_segment(const std::string& line)
    {
      _serialize.text("\""); _serialize.escape(line); _serialize.text("\"");
    }

    template<typename Lines>
    void render_lines(const Lines& lines)
    {
      auto string_opened = false;
      for (const auto& line : lines)
      {
        auto trailing_return = true;
        for (const auto& command : line)
        {
          switch(command.type)
          {
          case command_type::cpp:
            _serialize.text("            "); static_assert(std::is_same<decltype(close_string(string_opened)), void>::value, "$call{} requires void expression"); (close_string(string_opened)); _serialize.text("\n"
                   "            "); static_assert(std::is_same<decltype(cpp_line(command.text)), void>::value, "$call{} requires void expression"); (cpp_line(command.text)); _serialize.text("\n");
            break;
          case command_type::text:
            _serialize.text("            "); static_assert(std::is_same<decltype(open_string(string_opened)), void>::value, "$call{} requires void expression"); (open_string(string_opened)); _serialize.text("\n"
                   "            "); static_assert(std::is_same<decltype(text_segment(command.text)), void>::value, "$call{} requires void expression"); (text_segment(command.text)); _serialize.text("\n");
            break;
          case command_type::trim_trailing_return:
            trailing_return = false;
            break;
          case command_type::escape:
            _serialize.text("            "); static_assert(std::is_same<decltype(close_string(string_opened)), void>::value, "$call{} requires void expression"); (close_string(string_opened)); _serialize.text("\n"
                   "            "); static_assert(std::is_same<decltype(escape(command.text)), void>::value, "$call{} requires void expression"); (escape(command.text)); _serialize.text("\n");
            break;
            _serialize.text("    //ctx.open_text();\n"
                   "    //ctx.os << \"  \";\n"
                   "    //for (std::size_t i = 0; i < ctx.curly_level; ++i)\n"
                   "    //{\n"
                   "      //ctx.os << \"  \";\n"
                   "    //}\n");
          }
        }
      }
    }

  // ----------------------------------------------------------------------
#line 112
};

#line 112
template<typename DATA_T, typename SERIALIZER_T>
auto LineTemplate(const DATA_T& data, SERIALIZER_T& serialize)
  -> LineTemplate_t<kiste::terminal_t, DATA_T, SERIALIZER_T>
{
  return {kiste::terminal, data, serialize};
}

#line 113
}


